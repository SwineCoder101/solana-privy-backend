#include "imports/stdlib.fc";

;; Constants
const int OP_FUND_ESCROW = 1;
const int OP_COMPLETE_WORK = 2;
const int OP_BUYER_APPROVE = 3;
const int OP_BUYER_DISPUTE = 4;
const int OP_ARBITRATOR_DECISION = 5;
const int OP_CLAIM_FEES = 6;
const int OP_RELEASE_ESCROW = 7;

const int ERROR_ACCESS_DENIED = 401;
const int ERROR_INVALID_STATE = 402;
const int ERROR_INSUFFICIENT_FUNDS = 403;
const int ERROR_DEAL_EXPIRED = 404;

const int MAX_PERCENTAGE = 10000;
const int MIN_STORAGE_FEE = 10000000; ;; 0.01 TON
const int GAS_CONSUMPTION = 10000000; ;; 0.01 TON

const int SEND_MODE_REGULAR = 0;
const int SEND_MODE_PAY_FEES_SEPARATELY = 1;
const int SEND_MODE_IGNORE_ERRORS = 2;
const int SEND_MODE_CARRY_ALL_REMAINING_MESSAGE_VALUE = 64;

;; Storage structure
;; cell 1 (main_data):
;;   uint64 amount
;;   uint32 fee_percentage
;;   uint32 deal_expiration_time
;;   uint32 work_submission_time
;;   uint8  state
;; cell 2 (address_data):
;;   dict arbitrator_addresses
;;   slice seller_address
;;   slice buyer_address

;; Helper functions
(int, int, int, int, int) load_main_data() inline {
    slice cs = get_data().begin_parse();
    return (
        cs~load_uint(64),  ;; amount
        cs~load_uint(32),  ;; fee_percentage
        cs~load_uint(32),  ;; deal_expiration_time
        cs~load_uint(32),  ;; work_submission_time
        cs~load_uint(8)    ;; state
    );
}

(cell, slice, slice) load_address_data() inline {
    slice cs = get_data().begin_parse();
    cs~load_ref();
    cell address_data = cs~load_ref();
    slice address_cs = address_data.begin_parse();
    return (
        address_cs~load_dict(),  ;; arbitrator_addresses
        address_cs~load_msg_addr(),  ;; seller_address
        address_cs~load_msg_addr()   ;; buyer_address
    );
}

() save_data(int amount, int fee_percentage, int deal_expiration_time, int work_submission_time, int state, cell arbitrator_dict, slice seller_address, slice buyer_address) impure inline {
    set_data(begin_cell()
        .store_uint(amount, 64)
        .store_uint(fee_percentage, 32)
        .store_uint(deal_expiration_time, 32)
        .store_uint(work_submission_time, 32)
        .store_uint(state, 8)
        .store_ref(begin_cell()
            .store_dict(arbitrator_dict)
            .store_slice(seller_address)
            .store_slice(buyer_address)
            .end_cell())
        .end_cell());
}

() send_tons(slice to_address, int amount, int mode) impure inline {
    var msg = begin_cell()
        .store_uint(0x10, 6)
        .store_slice(to_address)
        .store_coins(amount)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1);
    send_raw_message(msg.end_cell(), mode);
}

slice parse_sender_address(cell in_msg_full) inline {
    var cs = in_msg_full.begin_parse();
    cs~load_uint(4);
    return cs~load_msg_addr();
}

int is_arbitrator(cell arbitrator_dict, slice address) inline {
    (_, int success) = arbitrator_dict.udict_get?(256, address.preload_uint(256));
    return success;
}

() send_event(int event_id, slice to_address) impure inline {
    var msg = begin_cell()
        .store_uint(0x10, 6)
        .store_slice(to_address)
        .store_coins(0)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_uint(event_id, 32);
    send_raw_message(msg.end_cell(), SEND_MODE_CARRY_ALL_REMAINING_MESSAGE_VALUE);
}

() return_excess_gas(slice to_address, int msg_value) impure inline {
    int excess = msg_value - MIN_STORAGE_FEE - GAS_CONSUMPTION;
    if (excess > 0) {
        send_tons(to_address, excess, SEND_MODE_CARRY_ALL_REMAINING_MESSAGE_VALUE);
    }
}

() recv_internal(int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) {
        return ();
    }

    slice sender_address = parse_sender_address(in_msg_full);
    int op = in_msg_body~load_uint(32);
    int query_id = in_msg_body~load_uint(64);

    (int amount, int fee_percentage, int deal_expiration_time, int work_submission_time, int state) = load_main_data();
    (cell arbitrator_dict, slice seller_address, slice buyer_address) = load_address_data();

    if (op == OP_FUND_ESCROW) {
        throw_unless(ERROR_INVALID_STATE, state == 0);
        throw_unless(ERROR_ACCESS_DENIED, equal_slices(sender_address, buyer_address));
        throw_unless(ERROR_INSUFFICIENT_FUNDS, msg_value > MIN_STORAGE_FEE + GAS_CONSUMPTION);

        ;; Update state before any external calls (Checks-Effects-Interactions pattern)
        amount = msg_value - MIN_STORAGE_FEE - GAS_CONSUMPTION;
        state = 1;
        save_data(amount, fee_percentage, deal_expiration_time, 0, state, arbitrator_dict, seller_address, buyer_address);

        return_excess_gas(sender_address, msg_value);
        return ();
    }

    if (op == OP_COMPLETE_WORK) {
        throw_unless(ERROR_INVALID_STATE, state == 1);
        throw_unless(ERROR_ACCESS_DENIED, equal_slices(sender_address, seller_address));
        
        ;; Update state before any external calls
        work_submission_time = now();
        state = 2;
        save_data(amount, fee_percentage, deal_expiration_time, work_submission_time, state, arbitrator_dict, seller_address, buyer_address);

        send_event(OP_COMPLETE_WORK, buyer_address);
        return_excess_gas(sender_address, msg_value);
        return ();
    }

    if (op == OP_BUYER_APPROVE) {
        throw_unless(ERROR_INVALID_STATE, state == 2);
        throw_unless(ERROR_ACCESS_DENIED, equal_slices(sender_address, buyer_address));

        int fee_amount = muldiv(amount, fee_percentage, MAX_PERCENTAGE);
        int seller_amount = amount - fee_amount;

        ;; Update state before any external calls
        state = 3;
        save_data(0, fee_percentage, deal_expiration_time, work_submission_time, state, arbitrator_dict, seller_address, buyer_address);

        send_tons(seller_address, seller_amount, SEND_MODE_PAY_FEES_SEPARATELY);
        
        ;; Send fee to the first arbitrator (this can be improved to distribute fees among arbitrators)
        (int min_key, slice first_arbitrator, int arbitrator_exists) = arbitrator_dict.udict_get_min?(256);
        if (~ arbitrator_exists) {
            ;; If no arbitrator, send fee to seller
            send_tons(seller_address, fee_amount, SEND_MODE_PAY_FEES_SEPARATELY);
        } else {
            send_tons(first_arbitrator, fee_amount, SEND_MODE_PAY_FEES_SEPARATELY);
        }

        return_excess_gas(sender_address, msg_value);
        return ();
    }

    if (op == OP_BUYER_DISPUTE) {
        throw_unless(ERROR_INVALID_STATE, state == 2);
        throw_unless(ERROR_ACCESS_DENIED, equal_slices(sender_address, buyer_address));

        ;; Update state before any external calls
        state = 4;
        save_data(amount, fee_percentage, deal_expiration_time, work_submission_time, state, arbitrator_dict, seller_address, buyer_address);

        ;; Send dispute event to all arbitrators
        int key = -1;
        do {
            (key, slice arbitrator, int success) = arbitrator_dict.udict_get_next?(256, key);
            if (success) {
                send_event(OP_BUYER_DISPUTE, arbitrator);
            }
        } until (~ success);

        return_excess_gas(sender_address, msg_value);
        return ();
    }

    if (op == OP_ARBITRATOR_DECISION) {
        throw_unless(ERROR_INVALID_STATE, state == 4);
        throw_unless(ERROR_ACCESS_DENIED, is_arbitrator(arbitrator_dict, sender_address));

        int seller_percentage = in_msg_body~load_uint(16);
        throw_unless(ERROR_INVALID_STATE, seller_percentage <= MAX_PERCENTAGE);
        int buyer_percentage = MAX_PERCENTAGE - seller_percentage;

        int fee_amount = muldiv(amount, fee_percentage, MAX_PERCENTAGE);
        int seller_amount = muldiv(amount - fee_amount, seller_percentage, MAX_PERCENTAGE);
        int buyer_amount = amount - fee_amount - seller_amount;

        ;; Update state before any external calls
        state = 5;
        save_data(0, fee_percentage, deal_expiration_time, work_submission_time, state, arbitrator_dict, seller_address, buyer_address);

        send_tons(seller_address, seller_amount, SEND_MODE_PAY_FEES_SEPARATELY);
        send_tons(buyer_address, buyer_amount, SEND_MODE_PAY_FEES_SEPARATELY);
        send_tons(sender_address, fee_amount, SEND_MODE_PAY_FEES_SEPARATELY);

        return_excess_gas(sender_address, msg_value);
        return ();
    }

    if (op == OP_CLAIM_FEES) {
        throw_unless(ERROR_ACCESS_DENIED, is_arbitrator(arbitrator_dict, sender_address));
        throw_unless(ERROR_INVALID_STATE, (state == 3) | (state == 5));

        ;; Update state before any external calls
        state = 6;
        save_data(0, fee_percentage, deal_expiration_time, work_submission_time, state, arbitrator_dict, seller_address, buyer_address);

        send_tons(sender_address, 0, SEND_MODE_CARRY_ALL_REMAINING_MESSAGE_VALUE);
        return ();
    }

    if (op == OP_RELEASE_ESCROW) {
        throw_unless(ERROR_INVALID_STATE, state == 1);
        throw_unless(ERROR_DEAL_EXPIRED, now() >= deal_expiration_time);

        ;; Update state before any external calls
        state = 7;
        save_data(0, fee_percentage, deal_expiration_time, work_submission_time, state, arbitrator_dict, seller_address, buyer_address);

        send_tons(buyer_address, amount, SEND_MODE_PAY_FEES_SEPARATELY);
        return_excess_gas(sender_address, msg_value);
        return ();
    }

    throw(0xffff);
}

;; Get methods

(int, int, int, int, int, cell, slice, slice) get_escrow_info() method_id {
    (int amount, int fee_percentage, int deal_expiration_time, int work_submission_time, int state) = load_main_data();
    (cell arbitrator_dict, slice seller_address, slice buyer_address) = load_address_data();
    return (amount, fee_percentage, deal_expiration_time, work_submission_time, state, arbitrator_dict, seller_address, buyer_address);
}

int get_escrow_state() method_id {
    (_, _, _, _, int state) = load_main_data();
    return state;
}